package scanner

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/Neo23x0/yarern-go/internal/extractor"
)

var RelevantExtensions = map[string]bool{
	".asp": true, ".vbs": true, ".ps": true, ".ps1": true, ".tmp": true,
	".bas": true, ".bat": true, ".cmd": true, ".com": true, ".cpl": true,
	".crt": true, ".dll": true, ".exe": true, ".msc": true, ".scr": true,
	".sys": true, ".vb": true, ".vbe": true, ".wsc": true, ".wsf": true,
	".wsh": true, ".input": true, ".war": true, ".jsp": true, ".php": true,
	".aspx": true, ".psd1": true, ".psm1": true, ".py": true,
}

type ScanOptions struct {
	Recursive          bool
	OnlyExecutables    bool
	MaxFileSizeMB      int
	MinStringLength    int
	MaxStringLength    int
	IncludeOpcodes     bool
	NumOpcodes         int
}

func DefaultScanOptions() ScanOptions {
	return ScanOptions{
		Recursive:       true,
		OnlyExecutables: false,
		MaxFileSizeMB:   10,
		MinStringLength: 8,
		MaxStringLength: 128,
		IncludeOpcodes:  true,
		NumOpcodes:      3,
	}
}

type FileInfo struct {
	Path    string
	Name    string
	Hash    string
	Size    int64
	Magic   string
	Strings []string
	Opcodes []string
}

type ScanResult struct {
	Files        []FileInfo
	StringStats  map[string]*StringStat
	OpcodeStats  map[string]*OpcodeStat
}

type StringStat struct {
	Count         int
	Files         []string
	FilesBasename map[string]int
}

type OpcodeStat struct {
	Count         int
	Files         []string
	FilesBasename map[string]int
}

func ScanMalwareDir(dir string, opts ScanOptions, progressFn func(path string)) (*ScanResult, error) {
	result := &ScanResult{
		Files:       make([]FileInfo, 0),
		StringStats: make(map[string]*StringStat),
		OpcodeStats: make(map[string]*OpcodeStat),
	}

	seenHashes := make(map[string]bool)

	err := walkDir(dir, opts.Recursive, func(path string) error {
		if progressFn != nil {
			progressFn(path)
		}

		info, err := os.Stat(path)
		if err != nil {
			return nil
		}

		if info.IsDir() {
			return nil
		}

		if opts.OnlyExecutables {
			ext := strings.ToLower(filepath.Ext(path))
			if !RelevantExtensions[ext] {
				return nil
			}
		}

		if opts.MaxFileSizeMB > 0 && info.Size() > int64(opts.MaxFileSizeMB)*1024*1024 {
			return nil
		}

		data, err := os.ReadFile(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "[W] Cannot read file: %s\n", path)
			return nil
		}

		hash := sha256.Sum256(data)
		hashStr := hex.EncodeToString(hash[:])

		if seenHashes[hashStr] {
			fmt.Printf("[-] Skipping duplicate: %s\n", path)
			return nil
		}
		seenHashes[hashStr] = true

		fileInfo := FileInfo{
			Path:  path,
			Name:  filepath.Base(path),
			Hash:  hashStr,
			Size:  info.Size(),
			Magic: extractor.GetMagicHeader(data),
		}

		fileInfo.Strings = extractor.ExtractAllStrings(data, opts.MinStringLength, opts.MaxStringLength)

		if opts.IncludeOpcodes {
			opcodes, err := extractor.ExtractOpcodes(data, opts.NumOpcodes*3)
			if err == nil {
				fileInfo.Opcodes = opcodes
			}
		}

		for _, s := range fileInfo.Strings {
			if _, exists := result.StringStats[s]; !exists {
				result.StringStats[s] = &StringStat{
					Count:         0,
					Files:         make([]string, 0),
					FilesBasename: make(map[string]int),
				}
			}
			stat := result.StringStats[s]
			stat.Count++
			if !containsString(stat.Files, path) {
				stat.Files = append(stat.Files, path)
			}
			stat.FilesBasename[fileInfo.Name]++
		}

		for _, op := range fileInfo.Opcodes {
			if _, exists := result.OpcodeStats[op]; !exists {
				result.OpcodeStats[op] = &OpcodeStat{
					Count:         0,
					Files:         make([]string, 0),
					FilesBasename: make(map[string]int),
				}
			}
			stat := result.OpcodeStats[op]
			stat.Count++
			if !containsString(stat.Files, path) {
				stat.Files = append(stat.Files, path)
			}
			stat.FilesBasename[fileInfo.Name]++
		}

		result.Files = append(result.Files, fileInfo)
		return nil
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

func walkDir(dir string, recursive bool, fn func(string) error) error {
	if recursive {
		return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return nil
			}
			return fn(path)
		})
	}

	entries, err := os.ReadDir(dir)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		path := filepath.Join(dir, entry.Name())
		if err := fn(path); err != nil {
			return err
		}
	}

	return nil
}

func containsString(slice []string, s string) bool {
	for _, item := range slice {
		if item == s {
			return true
		}
	}
	return false
}
